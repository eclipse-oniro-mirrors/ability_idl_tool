/*
 * Copyright (c) 2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "foo_stub.h"

namespace test {

int32_t FooStub::OnRemoteRequest(
    uint32_t code,
    MessageParcel& data,
    MessageParcel& reply,
    MessageOption& option)
{
    std::u16string localDescriptor = GetDescriptor();
    std::u16string remoteDescriptor = data.ReadInterfaceToken();
    if (localDescriptor != remoteDescriptor) {
        return ERR_TRANSACTION_FAILED;
    }
    switch (static_cast<IFooIpcCode>(code)) {
        case IFooIpcCode::COMMAND_VOID_TEST_FUNC: {
            ErrCode errCode = void_test_func();
            if (!reply.WriteInt32(errCode)) {
                return ERR_INVALID_VALUE;
            }
            return ERR_NONE;
        }
        case IFooIpcCode::COMMAND_BOOL_TEST_FUNC: {
            std::unordered_map<bool, bool> inParam;
            int32_t inParamSize = data.ReadInt32();
            for (int32_t i81 = 0; i81 < inParamSize; ++i81) {
                bool key81 = data.ReadInt32() == 1 ? true : false;
                bool value81 = data.ReadInt32() == 1 ? true : false;
                inParam[key81] = value81;
            }
            std::unordered_map<bool, bool> outParam;
            std::unordered_map<bool, bool> inoutParam;
            int32_t inoutParamSize = data.ReadInt32();
            for (int32_t i82 = 0; i82 < inoutParamSize; ++i82) {
                bool key82 = data.ReadInt32() == 1 ? true : false;
                bool value82 = data.ReadInt32() == 1 ? true : false;
                inoutParam[key82] = value82;
            }
            std::unordered_map<bool, bool> result;
            ErrCode errCode = bool_test_func(inParam, outParam, inoutParam, result);
            if (!reply.WriteInt32(errCode)) {
                return ERR_INVALID_VALUE;
            }
            if (SUCCEEDED(errCode)) {
                if (outParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(outParam.size());
                for (auto it83 = outParam.begin(); it83 != outParam.end(); ++it83) {
                    if (!reply.WriteInt32((it83->first) ? 1 : 0)) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it83->second) ? 1 : 0)) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (inoutParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(inoutParam.size());
                for (auto it84 = inoutParam.begin(); it84 != inoutParam.end(); ++it84) {
                    if (!reply.WriteInt32((it84->first) ? 1 : 0)) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it84->second) ? 1 : 0)) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (result.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(result.size());
                for (auto it85 = result.begin(); it85 != result.end(); ++it85) {
                    if (!reply.WriteInt32((it85->first) ? 1 : 0)) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it85->second) ? 1 : 0)) {
                        return ERR_INVALID_DATA;
                    }
                }
            }
            return ERR_NONE;
        }
        case IFooIpcCode::COMMAND_BYTE_TEST_FUNC: {
            std::unordered_map<int8_t, int8_t> inParam;
            int32_t inParamSize = data.ReadInt32();
            for (int32_t i86 = 0; i86 < inParamSize; ++i86) {
                int8_t key86 = (int8_t)data.ReadInt32();
                int8_t value86 = (int8_t)data.ReadInt32();
                inParam[key86] = value86;
            }
            std::unordered_map<int8_t, int8_t> outParam;
            std::unordered_map<int8_t, int8_t> inoutParam;
            int32_t inoutParamSize = data.ReadInt32();
            for (int32_t i87 = 0; i87 < inoutParamSize; ++i87) {
                int8_t key87 = (int8_t)data.ReadInt32();
                int8_t value87 = (int8_t)data.ReadInt32();
                inoutParam[key87] = value87;
            }
            std::unordered_map<int8_t, int8_t> result;
            ErrCode errCode = byte_test_func(inParam, outParam, inoutParam, result);
            if (!reply.WriteInt32(errCode)) {
                return ERR_INVALID_VALUE;
            }
            if (SUCCEEDED(errCode)) {
                if (outParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(outParam.size());
                for (auto it88 = outParam.begin(); it88 != outParam.end(); ++it88) {
                    if (!reply.WriteInt32((it88->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it88->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (inoutParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(inoutParam.size());
                for (auto it89 = inoutParam.begin(); it89 != inoutParam.end(); ++it89) {
                    if (!reply.WriteInt32((it89->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it89->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (result.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(result.size());
                for (auto it90 = result.begin(); it90 != result.end(); ++it90) {
                    if (!reply.WriteInt32((it90->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it90->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
            }
            return ERR_NONE;
        }
        case IFooIpcCode::COMMAND_SHORT_TEST_FUNC: {
            std::unordered_map<short, short> inParam;
            int32_t inParamSize = data.ReadInt32();
            for (int32_t i91 = 0; i91 < inParamSize; ++i91) {
                short key91 = (short)data.ReadInt32();
                short value91 = (short)data.ReadInt32();
                inParam[key91] = value91;
            }
            std::unordered_map<short, short> outParam;
            std::unordered_map<short, short> inoutParam;
            int32_t inoutParamSize = data.ReadInt32();
            for (int32_t i92 = 0; i92 < inoutParamSize; ++i92) {
                short key92 = (short)data.ReadInt32();
                short value92 = (short)data.ReadInt32();
                inoutParam[key92] = value92;
            }
            std::unordered_map<short, short> result;
            ErrCode errCode = short_test_func(inParam, outParam, inoutParam, result);
            if (!reply.WriteInt32(errCode)) {
                return ERR_INVALID_VALUE;
            }
            if (SUCCEEDED(errCode)) {
                if (outParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(outParam.size());
                for (auto it93 = outParam.begin(); it93 != outParam.end(); ++it93) {
                    if (!reply.WriteInt32((it93->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it93->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (inoutParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(inoutParam.size());
                for (auto it94 = inoutParam.begin(); it94 != inoutParam.end(); ++it94) {
                    if (!reply.WriteInt32((it94->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it94->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (result.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(result.size());
                for (auto it95 = result.begin(); it95 != result.end(); ++it95) {
                    if (!reply.WriteInt32((it95->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it95->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
            }
            return ERR_NONE;
        }
        case IFooIpcCode::COMMAND_INT_TEST_FUNC: {
            std::unordered_map<int32_t, int32_t> inParam;
            int32_t inParamSize = data.ReadInt32();
            for (int32_t i96 = 0; i96 < inParamSize; ++i96) {
                int32_t key96 = data.ReadInt32();
                int32_t value96 = data.ReadInt32();
                inParam[key96] = value96;
            }
            std::unordered_map<int32_t, int32_t> outParam;
            std::unordered_map<int32_t, int32_t> inoutParam;
            int32_t inoutParamSize = data.ReadInt32();
            for (int32_t i97 = 0; i97 < inoutParamSize; ++i97) {
                int32_t key97 = data.ReadInt32();
                int32_t value97 = data.ReadInt32();
                inoutParam[key97] = value97;
            }
            std::unordered_map<int32_t, int32_t> result;
            ErrCode errCode = int_test_func(inParam, outParam, inoutParam, result);
            if (!reply.WriteInt32(errCode)) {
                return ERR_INVALID_VALUE;
            }
            if (SUCCEEDED(errCode)) {
                if (outParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(outParam.size());
                for (auto it98 = outParam.begin(); it98 != outParam.end(); ++it98) {
                    if (!reply.WriteInt32((it98->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it98->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (inoutParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(inoutParam.size());
                for (auto it99 = inoutParam.begin(); it99 != inoutParam.end(); ++it99) {
                    if (!reply.WriteInt32((it99->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it99->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (result.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(result.size());
                for (auto it100 = result.begin(); it100 != result.end(); ++it100) {
                    if (!reply.WriteInt32((it100->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it100->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
            }
            return ERR_NONE;
        }
        case IFooIpcCode::COMMAND_LONG_TEST_FUNC: {
            std::unordered_map<int64_t, int64_t> inParam;
            int32_t inParamSize = data.ReadInt32();
            for (int32_t i101 = 0; i101 < inParamSize; ++i101) {
                int64_t key101 = data.ReadInt64();
                int64_t value101 = data.ReadInt64();
                inParam[key101] = value101;
            }
            std::unordered_map<int64_t, int64_t> outParam;
            std::unordered_map<int64_t, int64_t> inoutParam;
            int32_t inoutParamSize = data.ReadInt32();
            for (int32_t i102 = 0; i102 < inoutParamSize; ++i102) {
                int64_t key102 = data.ReadInt64();
                int64_t value102 = data.ReadInt64();
                inoutParam[key102] = value102;
            }
            std::unordered_map<int64_t, int64_t> result;
            ErrCode errCode = long_test_func(inParam, outParam, inoutParam, result);
            if (!reply.WriteInt32(errCode)) {
                return ERR_INVALID_VALUE;
            }
            if (SUCCEEDED(errCode)) {
                if (outParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(outParam.size());
                for (auto it103 = outParam.begin(); it103 != outParam.end(); ++it103) {
                    if (!reply.WriteInt64((it103->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt64((it103->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (inoutParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(inoutParam.size());
                for (auto it104 = inoutParam.begin(); it104 != inoutParam.end(); ++it104) {
                    if (!reply.WriteInt64((it104->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt64((it104->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (result.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(result.size());
                for (auto it105 = result.begin(); it105 != result.end(); ++it105) {
                    if (!reply.WriteInt64((it105->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt64((it105->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
            }
            return ERR_NONE;
        }
        case IFooIpcCode::COMMAND_STRING_TEST_FUNC: {
            std::unordered_map<std::string, std::string> inParam;
            int32_t inParamSize = data.ReadInt32();
            for (int32_t i106 = 0; i106 < inParamSize; ++i106) {
                std::string key106 = Str16ToStr8(data.ReadString16());
                std::string value106 = Str16ToStr8(data.ReadString16());
                inParam[key106] = value106;
            }
            std::unordered_map<std::string, std::string> outParam;
            std::unordered_map<std::string, std::string> inoutParam;
            int32_t inoutParamSize = data.ReadInt32();
            for (int32_t i107 = 0; i107 < inoutParamSize; ++i107) {
                std::string key107 = Str16ToStr8(data.ReadString16());
                std::string value107 = Str16ToStr8(data.ReadString16());
                inoutParam[key107] = value107;
            }
            std::unordered_map<std::string, std::string> result;
            ErrCode errCode = string_test_func(inParam, outParam, inoutParam, result);
            if (!reply.WriteInt32(errCode)) {
                return ERR_INVALID_VALUE;
            }
            if (SUCCEEDED(errCode)) {
                if (outParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(outParam.size());
                for (auto it108 = outParam.begin(); it108 != outParam.end(); ++it108) {
                    if (!reply.WriteString16(Str8ToStr16((it108->first)))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteString16(Str8ToStr16((it108->second)))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (inoutParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(inoutParam.size());
                for (auto it109 = inoutParam.begin(); it109 != inoutParam.end(); ++it109) {
                    if (!reply.WriteString16(Str8ToStr16((it109->first)))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteString16(Str8ToStr16((it109->second)))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (result.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(result.size());
                for (auto it110 = result.begin(); it110 != result.end(); ++it110) {
                    if (!reply.WriteString16(Str8ToStr16((it110->first)))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteString16(Str8ToStr16((it110->second)))) {
                        return ERR_INVALID_DATA;
                    }
                }
            }
            return ERR_NONE;
        }
        case IFooIpcCode::COMMAND_FLOAT_TEST_FUNC: {
            std::unordered_map<float, float> inParam;
            int32_t inParamSize = data.ReadInt32();
            for (int32_t i111 = 0; i111 < inParamSize; ++i111) {
                float key111 = data.ReadFloat();
                float value111 = data.ReadFloat();
                inParam[key111] = value111;
            }
            std::unordered_map<float, float> outParam;
            std::unordered_map<float, float> inoutParam;
            int32_t inoutParamSize = data.ReadInt32();
            for (int32_t i112 = 0; i112 < inoutParamSize; ++i112) {
                float key112 = data.ReadFloat();
                float value112 = data.ReadFloat();
                inoutParam[key112] = value112;
            }
            std::unordered_map<float, float> result;
            ErrCode errCode = float_test_func(inParam, outParam, inoutParam, result);
            if (!reply.WriteInt32(errCode)) {
                return ERR_INVALID_VALUE;
            }
            if (SUCCEEDED(errCode)) {
                if (outParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(outParam.size());
                for (auto it113 = outParam.begin(); it113 != outParam.end(); ++it113) {
                    if (!reply.WriteFloat((it113->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteFloat((it113->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (inoutParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(inoutParam.size());
                for (auto it114 = inoutParam.begin(); it114 != inoutParam.end(); ++it114) {
                    if (!reply.WriteFloat((it114->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteFloat((it114->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (result.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(result.size());
                for (auto it115 = result.begin(); it115 != result.end(); ++it115) {
                    if (!reply.WriteFloat((it115->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteFloat((it115->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
            }
            return ERR_NONE;
        }
        case IFooIpcCode::COMMAND_DOUBLE_TEST_FUNC: {
            std::unordered_map<double, double> inParam;
            int32_t inParamSize = data.ReadInt32();
            for (int32_t i116 = 0; i116 < inParamSize; ++i116) {
                double key116 = data.ReadDouble();
                double value116 = data.ReadDouble();
                inParam[key116] = value116;
            }
            std::unordered_map<double, double> outParam;
            std::unordered_map<double, double> inoutParam;
            int32_t inoutParamSize = data.ReadInt32();
            for (int32_t i117 = 0; i117 < inoutParamSize; ++i117) {
                double key117 = data.ReadDouble();
                double value117 = data.ReadDouble();
                inoutParam[key117] = value117;
            }
            std::unordered_map<double, double> result;
            ErrCode errCode = double_test_func(inParam, outParam, inoutParam, result);
            if (!reply.WriteInt32(errCode)) {
                return ERR_INVALID_VALUE;
            }
            if (SUCCEEDED(errCode)) {
                if (outParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(outParam.size());
                for (auto it118 = outParam.begin(); it118 != outParam.end(); ++it118) {
                    if (!reply.WriteDouble((it118->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteDouble((it118->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (inoutParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(inoutParam.size());
                for (auto it119 = inoutParam.begin(); it119 != inoutParam.end(); ++it119) {
                    if (!reply.WriteDouble((it119->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteDouble((it119->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (result.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(result.size());
                for (auto it120 = result.begin(); it120 != result.end(); ++it120) {
                    if (!reply.WriteDouble((it120->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteDouble((it120->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
            }
            return ERR_NONE;
        }
        case IFooIpcCode::COMMAND_CHAR_TEST_FUNC: {
            std::unordered_map<char, char> inParam;
            int32_t inParamSize = data.ReadInt32();
            for (int32_t i121 = 0; i121 < inParamSize; ++i121) {
                char key121 = (char)data.ReadInt32();
                char value121 = (char)data.ReadInt32();
                inParam[key121] = value121;
            }
            std::unordered_map<char, char> outParam;
            std::unordered_map<char, char> inoutParam;
            int32_t inoutParamSize = data.ReadInt32();
            for (int32_t i122 = 0; i122 < inoutParamSize; ++i122) {
                char key122 = (char)data.ReadInt32();
                char value122 = (char)data.ReadInt32();
                inoutParam[key122] = value122;
            }
            std::unordered_map<char, char> result;
            ErrCode errCode = char_test_func(inParam, outParam, inoutParam, result);
            if (!reply.WriteInt32(errCode)) {
                return ERR_INVALID_VALUE;
            }
            if (SUCCEEDED(errCode)) {
                if (outParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(outParam.size());
                for (auto it123 = outParam.begin(); it123 != outParam.end(); ++it123) {
                    if (!reply.WriteInt32((it123->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it123->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (inoutParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(inoutParam.size());
                for (auto it124 = inoutParam.begin(); it124 != inoutParam.end(); ++it124) {
                    if (!reply.WriteInt32((it124->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it124->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (result.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(result.size());
                for (auto it125 = result.begin(); it125 != result.end(); ++it125) {
                    if (!reply.WriteInt32((it125->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteInt32((it125->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
            }
            return ERR_NONE;
        }
        case IFooIpcCode::COMMAND_SEQ_TEST_FUNC: {
            std::unordered_map<const myseq&, const myseq&> inParam;
            int32_t inParamSize = data.ReadInt32();
            for (int32_t i126 = 0; i126 < inParamSize; ++i126) {
                std::unique_ptr<myseq> key126(data.ReadParcelable<myseq>());
                if (!key126) {
                    return ERR_INVALID_DATA;
                }

                std::unique_ptr<myseq> value126(data.ReadParcelable<myseq>());
                if (!value126) {
                    return ERR_INVALID_DATA;
                }

                inParam[key126] = value126;
            }
            std::unordered_map<const myseq&, const myseq&> outParam;
            std::unordered_map<const myseq&, const myseq&> inoutParam;
            int32_t inoutParamSize = data.ReadInt32();
            for (int32_t i127 = 0; i127 < inoutParamSize; ++i127) {
                std::unique_ptr<myseq> key127(data.ReadParcelable<myseq>());
                if (!key127) {
                    return ERR_INVALID_DATA;
                }

                std::unique_ptr<myseq> value127(data.ReadParcelable<myseq>());
                if (!value127) {
                    return ERR_INVALID_DATA;
                }

                inoutParam[key127] = value127;
            }
            std::unordered_map<const myseq&, const myseq&> result;
            ErrCode errCode = seq_test_func(inParam, outParam, inoutParam, result);
            if (!reply.WriteInt32(errCode)) {
                return ERR_INVALID_VALUE;
            }
            if (SUCCEEDED(errCode)) {
                if (outParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(outParam.size());
                for (auto it128 = outParam.begin(); it128 != outParam.end(); ++it128) {
                    if (!reply.WriteParcelable(&(it128->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteParcelable(&(it128->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (inoutParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(inoutParam.size());
                for (auto it129 = inoutParam.begin(); it129 != inoutParam.end(); ++it129) {
                    if (!reply.WriteParcelable(&(it129->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteParcelable(&(it129->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (result.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(result.size());
                for (auto it130 = result.begin(); it130 != result.end(); ++it130) {
                    if (!reply.WriteParcelable(&(it130->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteParcelable(&(it130->second))) {
                        return ERR_INVALID_DATA;
                    }
                }
            }
            return ERR_NONE;
        }
        case IFooIpcCode::COMMAND_INTERFACE_TEST_FUNC: {
            std::unordered_map<sptr<myinterface>, sptr<myinterface>> inParam;
            int32_t inParamSize = data.ReadInt32();
            for (int32_t i131 = 0; i131 < inParamSize; ++i131) {
                sptr<myinterface> key131 = iface_cast<myinterface>(data.ReadRemoteObject());
                if (key131 == nullptr) {
                    return ERR_INVALID_DATA;
                }

                sptr<myinterface> value131 = iface_cast<myinterface>(data.ReadRemoteObject());
                if (value131 == nullptr) {
                    return ERR_INVALID_DATA;
                }

                inParam[key131] = value131;
            }
            std::unordered_map<sptr<myinterface>, sptr<myinterface>> outParam;
            std::unordered_map<sptr<myinterface>, sptr<myinterface>> inoutParam;
            int32_t inoutParamSize = data.ReadInt32();
            for (int32_t i132 = 0; i132 < inoutParamSize; ++i132) {
                sptr<myinterface> key132 = iface_cast<myinterface>(data.ReadRemoteObject());
                if (key132 == nullptr) {
                    return ERR_INVALID_DATA;
                }

                sptr<myinterface> value132 = iface_cast<myinterface>(data.ReadRemoteObject());
                if (value132 == nullptr) {
                    return ERR_INVALID_DATA;
                }

                inoutParam[key132] = value132;
            }
            std::unordered_map<sptr<myinterface>, sptr<myinterface>> result;
            ErrCode errCode = interface_test_func(inParam, outParam, inoutParam, result);
            if (!reply.WriteInt32(errCode)) {
                return ERR_INVALID_VALUE;
            }
            if (SUCCEEDED(errCode)) {
                if (outParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(outParam.size());
                for (auto it133 = outParam.begin(); it133 != outParam.end(); ++it133) {
                    if ((it133->first) == nullptr) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteRemoteObject((it133->first)->AsObject())) {
                        return ERR_INVALID_DATA;
                    }
                    if ((it133->second) == nullptr) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteRemoteObject((it133->second)->AsObject())) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (inoutParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(inoutParam.size());
                for (auto it134 = inoutParam.begin(); it134 != inoutParam.end(); ++it134) {
                    if ((it134->first) == nullptr) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteRemoteObject((it134->first)->AsObject())) {
                        return ERR_INVALID_DATA;
                    }
                    if ((it134->second) == nullptr) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteRemoteObject((it134->second)->AsObject())) {
                        return ERR_INVALID_DATA;
                    }
                }
                if (result.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(result.size());
                for (auto it135 = result.begin(); it135 != result.end(); ++it135) {
                    if ((it135->first) == nullptr) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteRemoteObject((it135->first)->AsObject())) {
                        return ERR_INVALID_DATA;
                    }
                    if ((it135->second) == nullptr) {
                        return ERR_INVALID_DATA;
                    }
                    if (!reply.WriteRemoteObject((it135->second)->AsObject())) {
                        return ERR_INVALID_DATA;
                    }
                }
            }
            return ERR_NONE;
        }
        case IFooIpcCode::COMMAND_INT_2_TEST_FUNC: {
            std::unordered_map<int32_t, std::vector<int32_t>> inParam;
            int32_t inParamSize = data.ReadInt32();
            for (int32_t i136 = 0; i136 < inParamSize; ++i136) {
                int32_t key136 = data.ReadInt32();
                std::vector<int32_t> value136;
                int32_t value136Size = data.ReadInt32();
                if (value136Size > static_cast<int32_t>(VECTOR_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }
                for (int32_t i137 = 0; i137 < value136Size; ++i137) {
                    int32_t value137 = data.ReadInt32();
                    value136.push_back(value137);
                }
                inParam[key136] = value136;
            }
            std::unordered_map<int32_t, std::vector<int32_t>> outParam;
            std::unordered_map<int32_t, std::vector<int32_t>> inoutParam;
            int32_t inoutParamSize = data.ReadInt32();
            for (int32_t i138 = 0; i138 < inoutParamSize; ++i138) {
                int32_t key138 = data.ReadInt32();
                std::vector<int32_t> value138;
                int32_t value138Size = data.ReadInt32();
                if (value138Size > static_cast<int32_t>(VECTOR_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }
                for (int32_t i139 = 0; i139 < value138Size; ++i139) {
                    int32_t value139 = data.ReadInt32();
                    value138.push_back(value139);
                }
                inoutParam[key138] = value138;
            }
            std::unordered_map<int32_t, std::vector<int32_t>> result;
            ErrCode errCode = int_2_test_func(inParam, outParam, inoutParam, result);
            if (!reply.WriteInt32(errCode)) {
                return ERR_INVALID_VALUE;
            }
            if (SUCCEEDED(errCode)) {
                if (outParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(outParam.size());
                for (auto it140 = outParam.begin(); it140 != outParam.end(); ++it140) {
                    if (!reply.WriteInt32((it140->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if ((it140->second).size() > static_cast<size_t>(VECTOR_MAX_SIZE)) {
                        return ERR_INVALID_DATA;
                    }
                    reply.WriteInt32((it140->second).size());
                    for (auto it141 = (it140->second).begin(); it141 != (it140->second).end(); ++it141) {
                        if (!reply.WriteInt32((*it141))) {
                            return ERR_INVALID_DATA;
                        }
                    }
                }
                if (inoutParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(inoutParam.size());
                for (auto it142 = inoutParam.begin(); it142 != inoutParam.end(); ++it142) {
                    if (!reply.WriteInt32((it142->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if ((it142->second).size() > static_cast<size_t>(VECTOR_MAX_SIZE)) {
                        return ERR_INVALID_DATA;
                    }
                    reply.WriteInt32((it142->second).size());
                    for (auto it143 = (it142->second).begin(); it143 != (it142->second).end(); ++it143) {
                        if (!reply.WriteInt32((*it143))) {
                            return ERR_INVALID_DATA;
                        }
                    }
                }
                if (result.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(result.size());
                for (auto it144 = result.begin(); it144 != result.end(); ++it144) {
                    if (!reply.WriteInt32((it144->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if ((it144->second).size() > static_cast<size_t>(VECTOR_MAX_SIZE)) {
                        return ERR_INVALID_DATA;
                    }
                    reply.WriteInt32((it144->second).size());
                    for (auto it145 = (it144->second).begin(); it145 != (it144->second).end(); ++it145) {
                        if (!reply.WriteInt32((*it145))) {
                            return ERR_INVALID_DATA;
                        }
                    }
                }
            }
            return ERR_NONE;
        }
        case IFooIpcCode::COMMAND_MAP_TEST_FUNC: {
            std::unordered_map<int32_t, std::unordered_map<int32_t, std::vector<int32_t>>> inParam;
            int32_t inParamSize = data.ReadInt32();
            for (int32_t i146 = 0; i146 < inParamSize; ++i146) {
                int32_t key146 = data.ReadInt32();
                std::unordered_map<int32_t, std::vector<int32_t>> value146;
                int32_t value146Size = data.ReadInt32();
                for (int32_t i147 = 0; i147 < value146Size; ++i147) {
                    int32_t key147 = data.ReadInt32();
                    std::vector<int32_t> value147;
                    int32_t value147Size = data.ReadInt32();
                    if (value147Size > static_cast<int32_t>(VECTOR_MAX_SIZE)) {
                        return ERR_INVALID_DATA;
                    }
                    for (int32_t i148 = 0; i148 < value147Size; ++i148) {
                        int32_t value148 = data.ReadInt32();
                        value147.push_back(value148);
                    }
                    value146[key147] = value147;
                }
                inParam[key146] = value146;
            }
            std::unordered_map<int32_t, std::unordered_map<int32_t, std::vector<int32_t>>> outParam;
            std::unordered_map<int32_t, std::unordered_map<int32_t, std::vector<int32_t>>> inoutParam;
            int32_t inoutParamSize = data.ReadInt32();
            for (int32_t i149 = 0; i149 < inoutParamSize; ++i149) {
                int32_t key149 = data.ReadInt32();
                std::unordered_map<int32_t, std::vector<int32_t>> value149;
                int32_t value149Size = data.ReadInt32();
                for (int32_t i150 = 0; i150 < value149Size; ++i150) {
                    int32_t key150 = data.ReadInt32();
                    std::vector<int32_t> value150;
                    int32_t value150Size = data.ReadInt32();
                    if (value150Size > static_cast<int32_t>(VECTOR_MAX_SIZE)) {
                        return ERR_INVALID_DATA;
                    }
                    for (int32_t i151 = 0; i151 < value150Size; ++i151) {
                        int32_t value151 = data.ReadInt32();
                        value150.push_back(value151);
                    }
                    value149[key150] = value150;
                }
                inoutParam[key149] = value149;
            }
            std::unordered_map<int32_t, std::unordered_map<int32_t, std::vector<int32_t>>> result;
            ErrCode errCode = map_test_func(inParam, outParam, inoutParam, result);
            if (!reply.WriteInt32(errCode)) {
                return ERR_INVALID_VALUE;
            }
            if (SUCCEEDED(errCode)) {
                if (outParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(outParam.size());
                for (auto it152 = outParam.begin(); it152 != outParam.end(); ++it152) {
                    if (!reply.WriteInt32((it152->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if ((it152->second).size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                        return ERR_INVALID_DATA;
                    }

                    reply.WriteInt32((it152->second).size());
                    for (auto it153 = (it152->second).begin(); it153 != (it152->second).end(); ++it153) {
                        if (!reply.WriteInt32((it153->first))) {
                            return ERR_INVALID_DATA;
                        }
                        if ((it153->second).size() > static_cast<size_t>(VECTOR_MAX_SIZE)) {
                            return ERR_INVALID_DATA;
                        }
                        reply.WriteInt32((it153->second).size());
                        for (auto it154 = (it153->second).begin(); it154 != (it153->second).end(); ++it154) {
                            if (!reply.WriteInt32((*it154))) {
                                return ERR_INVALID_DATA;
                            }
                        }
                    }
                }
                if (inoutParam.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(inoutParam.size());
                for (auto it155 = inoutParam.begin(); it155 != inoutParam.end(); ++it155) {
                    if (!reply.WriteInt32((it155->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if ((it155->second).size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                        return ERR_INVALID_DATA;
                    }

                    reply.WriteInt32((it155->second).size());
                    for (auto it156 = (it155->second).begin(); it156 != (it155->second).end(); ++it156) {
                        if (!reply.WriteInt32((it156->first))) {
                            return ERR_INVALID_DATA;
                        }
                        if ((it156->second).size() > static_cast<size_t>(VECTOR_MAX_SIZE)) {
                            return ERR_INVALID_DATA;
                        }
                        reply.WriteInt32((it156->second).size());
                        for (auto it157 = (it156->second).begin(); it157 != (it156->second).end(); ++it157) {
                            if (!reply.WriteInt32((*it157))) {
                                return ERR_INVALID_DATA;
                            }
                        }
                    }
                }
                if (result.size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                    return ERR_INVALID_DATA;
                }

                reply.WriteInt32(result.size());
                for (auto it158 = result.begin(); it158 != result.end(); ++it158) {
                    if (!reply.WriteInt32((it158->first))) {
                        return ERR_INVALID_DATA;
                    }
                    if ((it158->second).size() > static_cast<size_t>(MAP_MAX_SIZE)) {
                        return ERR_INVALID_DATA;
                    }

                    reply.WriteInt32((it158->second).size());
                    for (auto it159 = (it158->second).begin(); it159 != (it158->second).end(); ++it159) {
                        if (!reply.WriteInt32((it159->first))) {
                            return ERR_INVALID_DATA;
                        }
                        if ((it159->second).size() > static_cast<size_t>(VECTOR_MAX_SIZE)) {
                            return ERR_INVALID_DATA;
                        }
                        reply.WriteInt32((it159->second).size());
                        for (auto it160 = (it159->second).begin(); it160 != (it159->second).end(); ++it160) {
                            if (!reply.WriteInt32((*it160))) {
                                return ERR_INVALID_DATA;
                            }
                        }
                    }
                }
            }
            return ERR_NONE;
        }
        default:
            return IPCObjectStub::OnRemoteRequest(code, data, reply, option);
    }

    return ERR_TRANSACTION_FAILED;
}
} // namespace test
