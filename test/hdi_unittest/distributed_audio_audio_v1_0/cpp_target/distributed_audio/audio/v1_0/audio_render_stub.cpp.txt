/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "v1_0/audio_render_stub.h"
#include <hdf_base.h>
#include <hdf_core_log.h>
#include <iproxy_broker.h>
#include "distributed_audio/audio/v1_0/audio_callback_proxy.h"

#define HDF_LOG_TAG    audio_render_stub

namespace OHOS {
namespace HDI {
namespace DistributedAudio {
namespace Audio {
namespace V1_0 {
template<typename ElementType>
static bool ReadPodArray(MessageParcel &parcel, std::vector<ElementType> &data);


template<typename ElementType>
static bool ReadPodArray(MessageParcel &parcel, std::vector<ElementType> &data)
{
    data.clear();
    uint32_t size = 0;
    if (!parcel.ReadUint32(size)) {
        HDF_LOGE("%{public}s: failed to read size", __func__);
        return false;
    }

    if (size == 0) {
        return true;
    }
    const ElementType *dataPtr = reinterpret_cast<const ElementType*>(parcel.ReadUnpadBuffer(sizeof(ElementType) * size));
    if (dataPtr == nullptr) {
        HDF_LOGI("%{public}s: failed to read data", __func__);
        return false;
    }
    data.assign(dataPtr, dataPtr + size);
    return true;
}


OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStub(const sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> &impl)
    : IPCObjectStub(OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()), impl_(impl)
{
}

OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::~AudioRenderStub()
{
    HDF_LOGI("%{public}s enter", __func__);
    ObjectCollector::GetInstance().RemoveObject(impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::OnRemoteRequest(uint32_t code, MessageParcel& data, MessageParcel& reply, MessageOption& option)
{
    switch (code) {
        case CMD_AUDIO_RENDER_GET_VERSION:
            return AudioRenderStubGetVersion(data, reply, option);
        case CMD_AUDIO_RENDER_GET_LATENCY:
            return AudioRenderStubGetLatency(data, reply, option);
        case CMD_AUDIO_RENDER_RENDER_FRAME:
            return AudioRenderStubRenderFrame(data, reply, option);
        case CMD_AUDIO_RENDER_GET_RENDER_POSITION:
            return AudioRenderStubGetRenderPosition(data, reply, option);
        case CMD_AUDIO_RENDER_SET_RENDER_SPEED:
            return AudioRenderStubSetRenderSpeed(data, reply, option);
        case CMD_AUDIO_RENDER_GET_RENDER_SPEED:
            return AudioRenderStubGetRenderSpeed(data, reply, option);
        case CMD_AUDIO_RENDER_SET_CHANNEL_MODE:
            return AudioRenderStubSetChannelMode(data, reply, option);
        case CMD_AUDIO_RENDER_GET_CHANNEL_MODE:
            return AudioRenderStubGetChannelMode(data, reply, option);
        case CMD_AUDIO_RENDER_REG_CALLBACK:
            return AudioRenderStubRegCallback(data, reply, option);
        case CMD_AUDIO_RENDER_DRAIN_BUFFER:
            return AudioRenderStubDrainBuffer(data, reply, option);
        case CMD_AUDIO_RENDER_IS_SUPPORTS_DRAIN:
            return AudioRenderStubIsSupportsDrain(data, reply, option);
        case CMD_AUDIO_RENDER_CHECK_SCENE_CAPABILITY:
            return AudioRenderStubCheckSceneCapability(data, reply, option);
        case CMD_AUDIO_RENDER_SELECT_SCENE:
            return AudioRenderStubSelectScene(data, reply, option);
        case CMD_AUDIO_RENDER_SET_MUTE:
            return AudioRenderStubSetMute(data, reply, option);
        case CMD_AUDIO_RENDER_GET_MUTE:
            return AudioRenderStubGetMute(data, reply, option);
        case CMD_AUDIO_RENDER_SET_VOLUME:
            return AudioRenderStubSetVolume(data, reply, option);
        case CMD_AUDIO_RENDER_GET_VOLUME:
            return AudioRenderStubGetVolume(data, reply, option);
        case CMD_AUDIO_RENDER_GET_GAIN_THRESHOLD:
            return AudioRenderStubGetGainThreshold(data, reply, option);
        case CMD_AUDIO_RENDER_GET_GAIN:
            return AudioRenderStubGetGain(data, reply, option);
        case CMD_AUDIO_RENDER_SET_GAIN:
            return AudioRenderStubSetGain(data, reply, option);
        case CMD_AUDIO_RENDER_GET_FRAME_SIZE:
            return AudioRenderStubGetFrameSize(data, reply, option);
        case CMD_AUDIO_RENDER_GET_FRAME_COUNT:
            return AudioRenderStubGetFrameCount(data, reply, option);
        case CMD_AUDIO_RENDER_SET_SAMPLE_ATTRIBUTES:
            return AudioRenderStubSetSampleAttributes(data, reply, option);
        case CMD_AUDIO_RENDER_GET_SAMPLE_ATTRIBUTES:
            return AudioRenderStubGetSampleAttributes(data, reply, option);
        case CMD_AUDIO_RENDER_GET_CURRENT_CHANNEL_ID:
            return AudioRenderStubGetCurrentChannelId(data, reply, option);
        case CMD_AUDIO_RENDER_SET_EXTRA_PARAMS:
            return AudioRenderStubSetExtraParams(data, reply, option);
        case CMD_AUDIO_RENDER_GET_EXTRA_PARAMS:
            return AudioRenderStubGetExtraParams(data, reply, option);
        case CMD_AUDIO_RENDER_REQ_MMAP_BUFFER:
            return AudioRenderStubReqMmapBuffer(data, reply, option);
        case CMD_AUDIO_RENDER_GET_MMAP_POSITION:
            return AudioRenderStubGetMmapPosition(data, reply, option);
        case CMD_AUDIO_RENDER_ADD_AUDIO_EFFECT:
            return AudioRenderStubAddAudioEffect(data, reply, option);
        case CMD_AUDIO_RENDER_REMOVE_AUDIO_EFFECT:
            return AudioRenderStubRemoveAudioEffect(data, reply, option);
        case CMD_AUDIO_RENDER_GET_FRAME_BUFFER_SIZE:
            return AudioRenderStubGetFrameBufferSize(data, reply, option);
        case CMD_AUDIO_RENDER_START:
            return AudioRenderStubStart(data, reply, option);
        case CMD_AUDIO_RENDER_STOP:
            return AudioRenderStubStop(data, reply, option);
        case CMD_AUDIO_RENDER_PAUSE:
            return AudioRenderStubPause(data, reply, option);
        case CMD_AUDIO_RENDER_RESUME:
            return AudioRenderStubResume(data, reply, option);
        case CMD_AUDIO_RENDER_FLUSH:
            return AudioRenderStubFlush(data, reply, option);
        case CMD_AUDIO_RENDER_TURN_STANDBY_MODE:
            return AudioRenderStubTurnStandbyMode(data, reply, option);
        case CMD_AUDIO_RENDER_AUDIO_DEV_DUMP:
            return AudioRenderStubAudioDevDump(data, reply, option);
        case CMD_AUDIO_RENDER_IS_SUPPORTS_PAUSE_AND_RESUME:
            return AudioRenderStubIsSupportsPauseAndResume(data, reply, option);
        default: {
            HDF_LOGE("%{public}s: cmd %{public}d is not supported", __func__, code);
            return IPCObjectStub::OnRemoteRequest(code, data, reply, option);
        }
    }
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetLatency(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetLatency_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubRenderFrame(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubRenderFrame_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetRenderPosition(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetRenderPosition_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetRenderSpeed(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetRenderSpeed_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetRenderSpeed(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetRenderSpeed_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetChannelMode(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetChannelMode_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetChannelMode(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetChannelMode_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubRegCallback(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubRegCallback_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubDrainBuffer(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubDrainBuffer_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubIsSupportsDrain(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubIsSupportsDrain_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubCheckSceneCapability(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubCheckSceneCapability_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSelectScene(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSelectScene_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetMute(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetMute_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetMute(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetMute_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetVolume(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetVolume_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetVolume(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetVolume_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetGainThreshold(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetGainThreshold_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetGain(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetGain_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetGain(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetGain_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetFrameSize(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetFrameSize_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetFrameCount(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetFrameCount_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetSampleAttributes(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetSampleAttributes_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetSampleAttributes(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetSampleAttributes_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetCurrentChannelId(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetCurrentChannelId_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetExtraParams(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetExtraParams_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetExtraParams(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetExtraParams_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubReqMmapBuffer(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubReqMmapBuffer_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetMmapPosition(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetMmapPosition_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubAddAudioEffect(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubAddAudioEffect_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubRemoveAudioEffect(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubRemoveAudioEffect_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetFrameBufferSize(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetFrameBufferSize_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubStart(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubStart_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubStop(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubStop_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubPause(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubPause_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubResume(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubResume_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubFlush(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubFlush_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubTurnStandbyMode(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubTurnStandbyMode_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubAudioDevDump(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubAudioDevDump_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubIsSupportsPauseAndResume(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubIsSupportsPauseAndResume_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetVersion(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption)
{
    return OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetVersion_(audioRenderData, audioRenderReply, audioRenderOption, impl_);
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetLatency_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    uint32_t ms = 0;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetLatency(ms);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteUint32(ms)) {
        HDF_LOGE("%{public}s: write ms failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubRenderFrame_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    std::vector<int8_t> frame;
    if (!ReadPodArray(audioRenderData, frame)) {
        HDF_LOGE("%{public}s: failed to read frame", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    uint64_t replyBytes = 0;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->RenderFrame(frame, replyBytes);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteUint64(replyBytes)) {
        HDF_LOGE("%{public}s: write replyBytes failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetRenderPosition_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    uint64_t frames = 0;

    OHOS::HDI::DistributedAudio::Audio::V1_0::AudioTimeStamp time;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetRenderPosition(frames, time);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteUint64(frames)) {
        HDF_LOGE("%{public}s: write frames failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (!OHOS::HDI::DistributedAudio::Audio::V1_0::AudioTimeStampBlockMarshalling(audioRenderReply, time)) {
        HDF_LOGE("%{public}s: write time failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetRenderSpeed_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    float speed = 0;
    if (!audioRenderData.ReadFloat(speed)) {
        HDF_LOGE("%{public}s: read speed failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->SetRenderSpeed(speed);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetRenderSpeed_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    float speed = 0;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetRenderSpeed(speed);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteFloat(speed)) {
        HDF_LOGE("%{public}s: write speed failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetChannelMode_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    OHOS::HDI::DistributedAudio::Audio::V1_0::AudioChannelMode mode = static_cast<enum AudioChannelMode>(0);
    {
        uint64_t enumTmp = 0;
        if (!audioRenderData.ReadUint64(enumTmp)) {
            HDF_LOGE("%{public}s: write mode failed!", __func__);
            return HDF_ERR_INVALID_PARAM;
        }
        mode = static_cast<enum AudioChannelMode>(enumTmp);
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->SetChannelMode(mode);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetChannelMode_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    OHOS::HDI::DistributedAudio::Audio::V1_0::AudioChannelMode mode;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetChannelMode(mode);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteUint64(static_cast<uint64_t>(mode))) {
        HDF_LOGE("%{public}s: write mode failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubRegCallback_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioCallback> audioCallback;
    sptr<IRemoteObject> audioCallbackRemote = audioRenderData.ReadRemoteObject();
    if (audioCallbackRemote == nullptr) {
        HDF_LOGE("%{public}s: read an invalid remote object", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    audioCallback = new OHOS::HDI::DistributedAudio::Audio::V1_0::AudioCallbackProxy(audioCallbackRemote);
    if (audioCallback == nullptr) {
        HDF_LOGE("%{public}s: failed to create interface object", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int8_t cookie = 0;
    if (!audioRenderData.ReadInt8(cookie)) {
        HDF_LOGE("%{public}s: read cookie failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->RegCallback(audioCallback, cookie);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubDrainBuffer_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    OHOS::HDI::DistributedAudio::Audio::V1_0::AudioDrainNotifyType type;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->DrainBuffer(type);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteUint64(static_cast<uint64_t>(type))) {
        HDF_LOGE("%{public}s: write type failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubIsSupportsDrain_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    bool support = false;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->IsSupportsDrain(support);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteBool(support)) {
        HDF_LOGE("%{public}s: write support failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubCheckSceneCapability_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    OHOS::HDI::DistributedAudio::Audio::V1_0::AudioSceneDescriptor scene;
    if (!AudioSceneDescriptorBlockUnmarshalling(audioRenderData, scene)) {
        HDF_LOGE("%{public}s: read scene failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    bool supported = false;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->CheckSceneCapability(scene, supported);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteBool(supported)) {
        HDF_LOGE("%{public}s: write supported failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSelectScene_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    OHOS::HDI::DistributedAudio::Audio::V1_0::AudioSceneDescriptor scene;
    if (!AudioSceneDescriptorBlockUnmarshalling(audioRenderData, scene)) {
        HDF_LOGE("%{public}s: read scene failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->SelectScene(scene);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetMute_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    bool mute = false;
    if (!audioRenderData.ReadBool(mute)) {
        HDF_LOGE("%{public}s: read mute failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->SetMute(mute);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetMute_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    bool mute = false;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetMute(mute);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteBool(mute)) {
        HDF_LOGE("%{public}s: write mute failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetVolume_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    float volume = 0;
    if (!audioRenderData.ReadFloat(volume)) {
        HDF_LOGE("%{public}s: read volume failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->SetVolume(volume);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetVolume_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    float volume = 0;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetVolume(volume);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteFloat(volume)) {
        HDF_LOGE("%{public}s: write volume failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetGainThreshold_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    float min = 0;

    float max = 0;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetGainThreshold(min, max);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteFloat(min)) {
        HDF_LOGE("%{public}s: write min failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (!audioRenderReply.WriteFloat(max)) {
        HDF_LOGE("%{public}s: write max failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetGain_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    float gain = 0;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetGain(gain);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteFloat(gain)) {
        HDF_LOGE("%{public}s: write gain failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetGain_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    float gain = 0;
    if (!audioRenderData.ReadFloat(gain)) {
        HDF_LOGE("%{public}s: read gain failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->SetGain(gain);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetFrameSize_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    uint64_t size = 0;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetFrameSize(size);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteUint64(size)) {
        HDF_LOGE("%{public}s: write size failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetFrameCount_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    uint64_t count = 0;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetFrameCount(count);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteUint64(count)) {
        HDF_LOGE("%{public}s: write count failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetSampleAttributes_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    OHOS::HDI::DistributedAudio::Audio::V1_0::AudioSampleAttributes attrs;
    if (!AudioSampleAttributesBlockUnmarshalling(audioRenderData, attrs)) {
        HDF_LOGE("%{public}s: read attrs failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->SetSampleAttributes(attrs);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetSampleAttributes_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    OHOS::HDI::DistributedAudio::Audio::V1_0::AudioSampleAttributes attrs;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetSampleAttributes(attrs);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!OHOS::HDI::DistributedAudio::Audio::V1_0::AudioSampleAttributesBlockMarshalling(audioRenderReply, attrs)) {
        HDF_LOGE("%{public}s: write attrs failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetCurrentChannelId_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    uint32_t channelId = 0;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetCurrentChannelId(channelId);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteUint32(channelId)) {
        HDF_LOGE("%{public}s: write channelId failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubSetExtraParams_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    const char* keyValueListCp = audioRenderData.ReadCString();
    if (keyValueListCp == nullptr) {
        HDF_LOGE("%{public}s: read keyValueList failed", __func__);
        return HDF_ERR_INVALID_PARAM;
    }
    std::string keyValueList = keyValueListCp;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->SetExtraParams(keyValueList);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetExtraParams_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    bool audioRenderMemSet = false;
    if (!audioRenderData.ReadBool(audioRenderMemSet)) {
        HDF_LOGE("%{public}s: failed to read audioRenderMemSet", __func__);
        return HDF_ERR_INVALID_PARAM;
    }
    std::string keyValueList;
    if (audioRenderMemSet) {
        uint32_t capacity = 0;
        if (!audioRenderData.ReadUint32(capacity)) {
            HDF_LOGE("%{public}s: failed to read capacity", __func__);
            return HDF_ERR_INVALID_PARAM;
        }
        HDI_CHECK_VALUE_RETURN(capacity, >, HDI_BUFF_MAX_SIZE / sizeof(char), HDF_ERR_INVALID_PARAM);
        keyValueList.reserve(capacity);
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetExtraParams(keyValueList);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteCString(keyValueList.c_str())) {
        HDF_LOGE("%{public}s: write keyValueList failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubReqMmapBuffer_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t reqSize = 0;
    if (!audioRenderData.ReadInt32(reqSize)) {
        HDF_LOGE("%{public}s: read reqSize failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    OHOS::HDI::DistributedAudio::Audio::V1_0::AudioMmapBufferDescriptor desc;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->ReqMmapBuffer(reqSize, desc);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!OHOS::HDI::DistributedAudio::Audio::V1_0::AudioMmapBufferDescriptorBlockMarshalling(audioRenderReply, desc)) {
        HDF_LOGE("%{public}s: write desc failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetMmapPosition_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    uint64_t frames = 0;

    OHOS::HDI::DistributedAudio::Audio::V1_0::AudioTimeStamp time;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetMmapPosition(frames, time);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteUint64(frames)) {
        HDF_LOGE("%{public}s: write frames failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (!OHOS::HDI::DistributedAudio::Audio::V1_0::AudioTimeStampBlockMarshalling(audioRenderReply, time)) {
        HDF_LOGE("%{public}s: write time failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubAddAudioEffect_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    uint64_t effectid = 0;
    if (!audioRenderData.ReadUint64(effectid)) {
        HDF_LOGE("%{public}s: read effectid failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->AddAudioEffect(effectid);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubRemoveAudioEffect_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    uint64_t effectid = 0;
    if (!audioRenderData.ReadUint64(effectid)) {
        HDF_LOGE("%{public}s: read effectid failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->RemoveAudioEffect(effectid);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetFrameBufferSize_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    uint64_t bufferSize = 0;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetFrameBufferSize(bufferSize);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteUint64(bufferSize)) {
        HDF_LOGE("%{public}s: write bufferSize failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubStart_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->Start();
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubStop_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->Stop();
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubPause_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->Pause();
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubResume_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->Resume();
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubFlush_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->Flush();
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubTurnStandbyMode_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->TurnStandbyMode();
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubAudioDevDump_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t range = 0;
    if (!audioRenderData.ReadInt32(range)) {
        HDF_LOGE("%{public}s: read range failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t fd = 0;
    if (!audioRenderData.ReadInt32(fd)) {
        HDF_LOGE("%{public}s: read fd failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->AudioDevDump(range, fd);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubIsSupportsPauseAndResume_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    bool supportPause = false;

    bool supportResume = false;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->IsSupportsPauseAndResume(supportPause, supportResume);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteBool(supportPause)) {
        HDF_LOGE("%{public}s: write supportPause failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (!audioRenderReply.WriteBool(supportResume)) {
        HDF_LOGE("%{public}s: write supportResume failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}

int32_t OHOS::HDI::DistributedAudio::Audio::V1_0::AudioRenderStub::AudioRenderStubGetVersion_(MessageParcel& audioRenderData, MessageParcel& audioRenderReply, MessageOption& audioRenderOption, sptr<OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender> impl)
{
    if (audioRenderData.ReadInterfaceToken() != OHOS::HDI::DistributedAudio::Audio::V1_0::IAudioRender::GetDescriptor()) {
        HDF_LOGE("%{public}s: interface token check failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    uint32_t majorVer = 0;

    uint32_t minorVer = 0;

    if (impl == nullptr) {
        HDF_LOGE("%{public}s: impl is nullptr!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    int32_t audioRenderRet = impl->GetVersion(majorVer, minorVer);
    if (audioRenderRet != HDF_SUCCESS) {
        HDF_LOGE("%{public}s failed, error code is %{public}d", __func__, audioRenderRet);
        return audioRenderRet;
    }

    if (!audioRenderReply.WriteUint32(majorVer)) {
        HDF_LOGE("%{public}s: write majorVer failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    if (!audioRenderReply.WriteUint32(minorVer)) {
        HDF_LOGE("%{public}s: write minorVer failed!", __func__);
        return HDF_ERR_INVALID_PARAM;
    }

    return audioRenderRet;
}
} // V1_0
} // Audio
} // DistributedAudio
} // HDI
} // OHOS
